## L010

1. 要正确理解题意，需要pattern整体匹配到text整体。
2. 如果text为空，而pattern为非空，则为false。
3. 不会两个*连续出现。
4. bool（）函数。



## L011

1. 使用双指针。
2. recursive function有depth上限，所以不能用recursive function。



## L012

1. 方法一：{1000， 900， 500， 400， 100，...}从大到小除下来。

2. 方法二：逐级if else

   第一种方法较优
   
   

## L013

1. mapping
2. 对应值之后的值更大就减，否则就加，就可以解决4和9的问题







## L014

直来直去



## L015

1. 先固定一个值，然后进行双指针寻找，时间复杂度是O(N ^ 2), 如果先确定两个值的话，时间复杂度是O(N^3).
2. 在双指针寻找时可以用步长的方法，需要判断序列长度，对于短的序列应用步长定位更费时间。



## L016

1. 和15题一样的方法



## L017

直来直去



## L018

1. 先确定两个数后进行双指针。复杂度O(N^3).
2. 可以设立early stop加速，< target / 4,> target / 4, < target / 2, > target / 2


## L019

把链表塞到一个实实在在的表格里，之后直来直去。



## L035

如何在二分法寻找中，避免死循环



## L036

简单，将每个点按照行，列，组进行编码即可

## L037
1. 建立行 列 组 三个mem 用来存取当前board里的信息
2. 深度优先搜索 逐个grid向前填 如果没东西可填 返回false 可行反悔true
3. 目前可以优化的地方时存取信息的方式。目前使用的是set，由于可以转为使用长度为9的list，会更快。


## L038
知道题目啥意思就行了



## L057

二刷指数: **

没有特殊技巧，将新的interval的start和end按照if else塞进去就可以



## L058  最后一个单词的长度

。

